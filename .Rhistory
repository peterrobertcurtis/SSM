plot(1:10)
plot(10:1)
knitr::kable(head(mtcars, 10))
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library(SSM)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library(SSM)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
library(SSM)
X <- seq(-1, 1, 0.25)
Y <- sapply(X, "^", 2)
s1 <- fit.ssm(X, Y)
library(SSM)
X <- seq(-1, 1, 0.25)
Y <- sapply(X, "^", 2)
s1 <- fit.ssm(X, Y)
library(SSM)
fit.ssm()
library(SSM)
fit.ssm()
ls()
plot.SSM
SSM::fit.ssm()
search()
library(SSM)
fit.ssm
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
X <- seq(-1, 1, 0.25)
Y <- sapply(X, "^", 2)
s1 <- fit.ssm(X, Y)
s1
library(SSM)
ls()
plot(s1)
predict(s1, 0.5)
library(SSM)
fit.ssm(design, responses, basis_size = 50)
design <- seq(-1, 1, 0.25)
responses <- sapply(design, "^", 2)
s <- fit.ssm(design, responses)
s
predict(s, 0.5)
plot(s)
fit.ssm(design, responses, basis_size = 50)
s   <- fit.ssm(design, responses)
s50 <- fit.ssm(design, responses, basis_size = 50)
s80 <- fit.ssm(design, responses, basis_size = 80)
s   <- fit.ssm(design, responses)
s50 <- fit.ssm(design, responses, basis_size = 50)
s70 <- fit.ssm(design, responses, basis_size = 70)
s100 <- fit.ssm(design, responses, basis_size = 100)
library(SSM)
s   <- fit.ssm(design, responses)
s50 <- fit.ssm(design, responses, basis_size = 50)
s70 <- fit.ssm(design, responses, basis_size = 70)
s100 <- fit.ssm(design, responses, basis_size = 100)
s   <- fit.ssm(design, responses)
plot(s)
s50 <- fit.ssm(design, responses, basis_size = 50)
plot(s50)
s70 <- fit.ssm(design, responses, basis_size = 70)
plot(s70)
s100 <- fit.ssm(design, responses, basis_size = 100)
s   <- fit.ssm(design, responses); s
plot(s, main=""
s50 <- fit.ssm(design, responses, basis_size = 50)
s   <- fit.ssm(design, responses); s
plot(s, main = "29 terms")
s50 <- fit.ssm(design, responses, basis_size = 50)
plot(s50, main = "50 terms")
s70 <- fit.ssm(design, responses, basis_size = 70)
plot(s70, main = "70 terms")
s100 <- fit.ssm(design, responses, basis_size = 100)
s   <- fit.ssm(design, responses); s
plot(s, main = "29 terms")
s50 <- fit.ssm(design, responses, basis_size = 50); s50
plot(s50, main = "50 terms")
s70 <- fit.ssm(design, responses, basis_size = 70); s70
plot(s70, main = "70 terms")
s100 <- fit.ssm(design, responses, basis_size = 100); s100
# default behaviour
s   <- fit.ssm(design, responses); s
# too large to fit
s100 <- fit.ssm(design, responses, basis_size = 100); s100
# instabilty indicated by plot
s70 <- fit.ssm(design, responses, basis_size = 70); s70
plot(s70, main = "70 terms")
s60 <- fit.ssm(design, responses, basis_size = 60); s60
plot(s60, main = "60 terms")
# default behaviour
s   <- fit.ssm(design, responses); s
# too large to fit
s100 <- fit.ssm(design, responses, basis_size = 100); s100
# instabilty indicated by plot
s70 <- fit.ssm(design, responses, basis_size = 70); s70
plot(s70, main = "70 terms")
s50 <- fit.ssm(design, responses, basis_size = 50); s50
plot(s50, main = "50 terms")
s <- fit.ssm(X, Y)
s1 <- fit.ssm(X[-1], Y[-1], ssm = s)
s <- fit.ssm(X, Y);s
s1 <- fit.ssm(X[-1], Y[-1], ssm = s);s1
s <- fit.ssm(X, Y);s
s1 <- fit.ssm(X[-2], Y[-2], ssm = s);s1
s <- fit.ssm(X, Y);s
s1 <- fit.ssm(X[-3], Y[-3], ssm = s);s1
s <- fit.ssm(X, Y);s
s1 <- fit.ssm(X[1:6], Y[1:6], ssm = s);s1
s <- fit.ssm(X, Y);s
s1 <- fit.ssm(X[1:5], Y[1:5], ssm = s);s1
s <- fit.ssm(X, Y);s
s1 <- fit.ssm(X[1:5], Y[1:5], ssm = s);s1
s <- fit.ssm(X, Y, basis_size=12);s
s1 <- fit.ssm(X[1:5], Y[1:5], ssm = s);s1
i <- sample(1:9,5)
s <- fit.ssm(X, Y, basis_size=12);s
s1 <- fit.ssm(X[1:5], Y[1:5], ssm = s);s1
i <- sample(1:9,5)
s <- fit.ssm(X, Y, basis_size=12);s
s1 <- fit.ssm(X[i, ], Y[i], ssm = s);s1
i <- sample(1:9,5)
s <- fit.ssm(X, Y, basis_size=12);s
s1 <- fit.ssm(X[i], Y[i], ssm = s);s1
i <- sample(1:9,5)
s <- fit.ssm(X, Y, basis_size=20);s
s1 <- fit.ssm(X[i], Y[i], ssm = s);s1
i <- sample(1:9,5)
s <- fit.ssm(X, Y, basis_size=30);s
s1 <- fit.ssm(X[i], Y[i], ssm = s);s1
i <- sample(1:9,5)
s <- fit.ssm(X, Y, basis_size=40);s
s1 <- fit.ssm(X[i], Y[i], ssm = s);s1
X <- matrix(runif(20, -1, 1), ncol = 2)
Y <- apply(X, 1, sum)
s <- fit.ssm(X, Y);s
s1 <- fit.ssm(X[i], Y[i], ssm = s);s1
X <- matrix(runif(20, -1, 1), ncol = 2)
Y <- apply(X, 1, sum)
s <- fit.ssm(X, Y);s
s1 <- fit.ssm(X, Y, ssm = s);s1
debug(fit.ssm)
s1 <- fit.ssm(X, Y, ssm = s);s1
find.theta(response, s@K[s@include, s@include], s@design_model_matrix[,
s@include])
s@include    <- ssm@include
theta <- find.theta(response,
s@K[s@include, s@include],
s@design_model_matrix[ , s@include])
theta
library(SSM)
X <- matrix(runif(20, -1, 1), ncol = 2)
Y <- apply(X, 1, sum)
s <- fit.ssm(X, Y);s
s1 <- fit.ssm(X, Y, ssm = s);s1
X <- matrix(runif(20, -1, 1), ncol = 2)
Y <- apply(X, 1, sum)
s <- fit.ssm(X, Y);s
s1 <- fit.ssm(X[1:9, ], Y[1:9], ssm = s);s1
# ten point design in two factors
X <- matrix(runif(20, -1, 1), ncol = 2)
Y <- apply(X, 1, sum)
# fit SSM
s <- fit.ssm(X, Y);s
# fit SSM with same structure to first nine design points only
s1 <- fit.ssm(X[1:9, ], Y[1:9], ssm = s);s1
design   <- matrix(runif(-1,1,40), ncol=4)
design   <- matrix(runif(40, -1,1), ncol=4)
response <- apply(design, 1, "*", c(1,2,3,4))
s        <- fit.ssm(design, response, SA = TRUE)
f <- function(x) sum(x * 1:4)
X <- matrix(runif(80, -1, 1), ncol = 4)
Y <- apply(X, 1, f)
s <- fit.ssm(X, Y, SA = TRUE)
sensitivity.plot(s)
f <- function(x) sum(x * 1:4)
X <- matrix(runif(80, -1, 1), ncol = 4)
Y <- apply(X, 1, f)
s <- fit.ssm(X, Y, SA = TRUE)
s
f <- function(x) sum(x * 1:4)
X <- matrix(runif(80, -1, 1), ncol = 4)
Y <- apply(X, 1, f)
s <- fit.ssm(X, Y, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
sensitivity.plot(s, "sobol")
library(SSM)
f <- function(x) sum(x * 1:4)
X <- matrix(runif(80, -1, 1), ncol = 4)
Y <- apply(X, 1, f)
s <- fit.ssm(X, Y, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
sensitivity.plot(s, "sobol")
f <- function(x) sum(x * 1:4) + x[1]*x[2]
X <- matrix(runif(80, -1, 1), ncol = 4)
Y <- apply(X, 1, f)
s <- fit.ssm(X, Y, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
sensitivity.plot(s, "sobol")
f <- function(x) sum(x * 1:4) + 10 * x[1]*x[2]
X <- matrix(runif(80, -1, 1), ncol = 4)
Y <- apply(X, 1, f)
s <- fit.ssm(X, Y, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
sensitivity.plot(s, "sobol")
f <- function(x) sum(x * 1:4) + 5 * x[1]*x[2]
X <- matrix(runif(80, -1, 1), ncol = 4)
Y <- apply(X, 1, f)
s <- fit.ssm(X, Y, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
sensitivity.plot(s, "sobol")
s <- fit.ssm(design, response, validation = TRUE)
f <- function(x) sum(x * 1:4) + 5 * x[1]*x[2]
design <- matrix(runif(80, -1, 1), ncol = 4)
response <- apply(design, 1, f)
s <- fit.ssm(design, response, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
# The grey bars indicate interactions
sensitivity.plot(s, "sobol")
s <- fit.ssm(design, response, validation = TRUE)
s
library(SSM)
s <- fit.ssm(design, response, validation = TRUE)
s
s <- fit.ssm(design, response, validation = TRUE)
s
library(SSM)
f <- function(x) sum(x * 1:4) + 5 * x[1]*x[2]
design <- matrix(runif(80, -1, 1), ncol = 4)
response <- apply(design, 1, f)
s <- fit.ssm(design, response, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
# The grey bars indicate interactions
sensitivity.plot(s, "sobol")
sensitivity.plot(S, "total")
f <- function(x) sum(x * 1:4) + 5 * x[1]*x[2]
design <- matrix(runif(80, -1, 1), ncol = 4)
response <- apply(design, 1, f)
s <- fit.ssm(design, response, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
# The grey bars indicate interactions
sensitivity.plot(s, "sobol")
sensitivity.plot(s, "total")
s <- fit.ssm(design, response, validation = TRUE, basis_size=200)
s
s <- fit.ssm(design, response, validation = TRUE, basis_size=150)
s
s <- fit.ssm(design, response, validation = TRUE)
s
s <- fit.ssm(design, response, validation = TRUE)
s
f <- function(x) sum(x * 1:4) + 5 * x[1]*x[2]
design <- matrix(runif(100, -1, 1), ncol = 4)
response <- apply(design, 1, f)
s <- fit.ssm(design, response, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
# The grey bars indicate interactions
sensitivity.plot(s, "sobol")
# This plots total indices for main effects, and total interaction indices for second order interactions
sensitivity.plot(s, "total")
s <- fit.ssm(design, response, validation = TRUE)
s
f <- function(x) sum(x * 1:4) + 5 * x[1]*x[2]
design <- matrix(runif(400, -1, 1), ncol = 4)
response <- apply(design, 1, f)
s <- fit.ssm(design, response, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
# The grey bars indicate interactions
sensitivity.plot(s, "sobol")
# This plots total indices for main effects, and total interaction indices for second order interactions
sensitivity.plot(s, "total")
s <- fit.ssm(design, response, validation = TRUE)
s
s <- fit.ssm(design, response, GP = TRUE)
plot(s)
design <- seq(-1, 1, 0.25)
responses <- sapply(design, "^", 2)
s <- fit.ssm(design, responses, GP = TRUE)
design <- seq(-1, 1, 0.25)
responses <- sapply(design, "^", 2)
s <- fit.ssm(design, responses, GP = TRUE)
plot(s)
design <- seq(-1, 1, 0.25)
responses <- sapply(design, "^", 2)
s <- fit.ssm(design, responses, GP = TRUE)
plot(s)
s <- fit.ssm(design, responses, GP = TRUE, type = "matern32")
plot(s)
design <- seq(-1, 1, 0.25)
responses <- sapply(design, "^", 2)
s1 <- fit.ssm(design, responses, GP = TRUE)
s2 <- fit.ssm(design, responses, GP = TRUE, type = "matern32")
plot(s1, main = "Squared exponential")
plot(s2, main = "Matern 3/2")
design <- seq(-1, 1, 0.25)
responses <- sapply(design, "^", 2)
s1 <- fit.ssm(design, responses, GP = TRUE)
s2 <- fit.ssm(design, responses, GP = TRUE, type = "matern32")
plot(s1, sub = "Squared exponential")
plot(s2, sub = "Matern 3/2")
s3 <- fit.ssm(design, response, SA = TRUE, exclude = list(c(1,3), c(1,4), c(2,3), c(2,4), c(3,4)))
f <- function(x) sum(x * 1:4) + 5 * x[1]*x[2]
design <- matrix(runif(400, -1, 1), ncol = 4)
response <- apply(design, 1, f)
s <- fit.ssm(design, response, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
# The grey bars indicate interactions
sensitivity.plot(s, "sobol")
# This plots total indices for main effects, and total interaction indices for second order interactions
sensitivity.plot(s, "total")
s <- fit.ssm(design, response, validation = TRUE)
s
degl(4,180,list(c(1,3)))
SSM::degl(4,180,list(c(1,3)))
degl <- function(d,N, exclude = list()){
## degl(d, N) generates a matrix of N hierarchical exponent vectors in d variables
## the optional argument exclude allows you to include a list of terms to exclude,
##  identified by integers.  For example exclude = list(1) will not include any
##  terms only in x_1.  exclude = list(1, c(2,3)) will exclude terms in x_1 and
##  in x_2x_3.
include <- 1
L <- matrix(0, nrow = 1, ncol = d)
count <- 1
deg <- 1
while(count < N){
n <- min(choose(d + deg - 1, deg), N - count)
new <- comb(d, deg, N = n, exclude = exclude)
if(length(new$include)==0) stop("All variables and interactions have been excluded")
include <- c(include, new$include + nrow(L))
n <- nrow(new$basis)
L <- rbind(L, new$basis)
count <- count + length(new$include)
deg <- deg + 1
}
return(list(basis = L, include = include))
}
comb <- function(d, deg, N = choose(d + deg - 1, deg), vec, start = TRUE,
parent, exclude = list()){
# start by initializing objects on initial call
if (start){
# number of vectors N to construct is either N or the number of possible
# combinations, whichever is smaller
N <- min(N, choose(d + deg -1, deg))
# L is the matrix that will contain the generated vectors
L <- matrix(nrow = choose(d + deg - 1, deg), ncol = d)
# count is a count of the number of included generated vectors
count <- 1
# vec is a d dimensional vector of zeroes
vec <- rep(0, d)
# include is a vector of indices indicating which matrix rows are included
# in the model basis
include <- rep(NA, N)
# record parent frame info to pass down recursion chain
parent <- sys.frame(sys.nframe())
# flag to mark when enough vectors have been generated and the matrix can be
# output
finish <- FALSE
} else {
# if this is not the inital call but is inside the recursion, get the
# current matrix of vectors and count from the initial environment
L <- get("L", envir = parent)
count <- get("count", envir = parent)
include <- get("include", envir = parent)
}
# if the recursion has completed, check the generated vector is not to be
# excluded and assign the generated vector to the correct row of the matrix L
# in the initial environment and add one to the count
if (deg == 0){
L[count, ] <- vec
assign("L", L, envir = parent)
assign("count", count + 1, envir=parent)
if (length(exclude)>0){
for (i in 1:length(exclude)) {
if (all(vec[exclude[[i]]] > 0) && all(vec [-exclude[[i]]] == 0)){
return()
}
}
}
include[match(TRUE, is.na(include))] <- count
assign("include", include, envir=parent)
if(sum(!is.na(include)) == N) assign("finish", TRUE, envir = parent)
return()
}
# recursive section: this adds one to an element of vec and passes it into
# comb again but with one less degree
for (i in max(which(vec != 0), 1):length(vec)){
if (get("finish", envir=parent) && !start) return()
if (get("finish", envir=parent))
return(list(basis=L[!is.na(L[, 1]), ],
include = include[!is.na(include)]))
addvec <- rep(0, d)
addvec[i] <- 1
comb(d = d, N = N, vec = vec + addvec, deg = deg - 1, start = FALSE, parent = parent, exclude = exclude)
}
ind <- is.na(L[,1])
# identify the rows of NA to remove when less than N rows are generated
return(list(basis=L[!ind,], include = include[!is.na(include)]))
}
degl(4,180, list(c(1,2))
)
s3 <- fit.ssm(design, response, SA = TRUE, exclude = list(c(1,3), c(1,4), c(2,3), c(2,4), c(3,4)))
s3 <- fit.ssm(design, response, SA = TRUE, exclude = list(c(1,3), c(1,4), c(2,3), c(2,4), c(3,4)))
s3
s3 <- fit.ssm(design, response, SA = TRUE, exclude = list(c(1,3), c(1,4), c(2,3), c(2,4), c(3,4)))
sensitivity.plot(s3, "total")
f <- function(x) sum(x * 1:4) + 5 * x[1]*x[2] + 0.2 *x[2]*x[3]
design <- matrix(runif(400, -1, 1), ncol = 4)
response <- apply(design, 1, f)
s <- fit.ssm(design, response, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
# The grey bars indicate interactions
sensitivity.plot(s, "sobol")
# This plots total indices for main effects, and total interaction indices for second order interactions
sensitivity.plot(s, "total")
f <- function(x) sum(x * 1:4) + 5 * x[1]*x[2] + x[2]*x[3]
design <- matrix(runif(400, -1, 1), ncol = 4)
response <- apply(design, 1, f)
s <- fit.ssm(design, response, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
# The grey bars indicate interactions
sensitivity.plot(s, "sobol")
# This plots total indices for main effects, and total interaction indices for second order interactions
sensitivity.plot(s, "total")
# fit new model without unnecessary second order interactions
s3 <- fit.ssm(design, response, SA = TRUE, exclude = list(c(1,3), c(1,4), c(2,3), c(2,4), c(3,4)))
sensitivity.plot(s3, "total")
f <- function(x) sum(x * 1:3) + 5 * x[1]*x[2]
design <- matrix(runif(300, -1, 1), ncol = 3)
response <- apply(design, 1, f)
s <- fit.ssm(design, response, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
# The grey bars indicate interactions
sensitivity.plot(s, "sobol")
# This plots total indices for main effects, and total interaction indices for second order interactions
sensitivity.plot(s, "total")
# fit new model without unnecessary second order interactions
s3 <- fit.ssm(design, response, SA = TRUE, exclude = list(c(1,3), c(2,3), c(1,2,3)))
sensitivity.plot(s3, "total")
# fit new model without unnecessary second order interactions
s3 <- fit.ssm(design, response, SA = TRUE, exclude = list(c(1,3), c(2,3), c(1,2,3)))
s3
sensitivity.plot(s3, "total")
# fit new model without unnecessary second order interactions
s3 <- fit.ssm(design, response, SA = TRUE, exclude = list(c(1,3), c(2,3), c(1,2,3)))
s3@basis
sensitivity.plot(s3, "total")
# fit new model without unnecessary second order interactions
s3 <- fit.ssm(design, response, SA = TRUE, exclude = list(c(1,2),c(1,3), c(2,3), c(1,2,3)))
# fit new model without any interactions
s3 <- fit.ssm(design, response, SA = TRUE, exclude = list(1))
s3
sensitivity.plot(s3, "total")
# fit new model without any interactions
s3 <- fit.ssm(design, response, SA = TRUE, exclude = list(1))
s3
sensitivity.plot(s3, "sobol")
library(SSM)
f <- function(x) sum(x * 1:3) + 5 * x[1]*x[2]
design <- matrix(runif(300, -1, 1), ncol = 3)
response <- apply(design, 1, f)
s <- fit.ssm(design, response, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
# The grey bars indicate interactions
sensitivity.plot(s, "sobol")
# This plots total indices for main effects, and total interaction indices for second order interactions
sensitivity.plot(s, "total", cex=0.5)
f <- function(x) sum(x * 1:3) + 5 * x[1]*x[2]
design <- matrix(runif(300, -1, 1), ncol = 3)
response <- apply(design, 1, f)
s <- fit.ssm(design, response, SA = TRUE)
s
sensitivity.plot(s, "main_sobol")
# The grey bars indicate interactions
sensitivity.plot(s, "sobol")
# This plots total indices for main effects, and total interaction indices for second order interactions
sensitivity.plot(s, "total", cex.main=0.5)
design <- seq(-1, 1, 0.25)
responses <- sapply(design, "^", 2)
s1 <- fit.ssm(design, responses, GP = TRUE)
s2 <- fit.ssm(design, responses, GP = TRUE, type = "matern32")
plot(s1, sub = "Squared exponential")
plot(s2, sub = "Matern 3/2")
library(SSM)
citation("SSM")
devtools::load_all()
citation("SSM")
library(SSM)
citation("SSM")
readCitationFile("SSM")
source('D:/horse/OneDrive/Current work/r package/SSM/inst/CITATION.R', echo=TRUE)
source('D:/horse/OneDrive/Current work/r package/SSM/inst/CITATION.R', echo=TRUE)
source('D:/horse/OneDrive/Current work/r package/SSM/inst/CITATION.R', echo=TRUE)
source('D:/horse/OneDrive/Current work/r package/SSM/inst/CITATION.R', echo=TRUE)
library(SSM)
citation("SSM")
source('D:/horse/OneDrive/Current work/r package/SSM/inst/CITATION.R', echo=TRUE)
library(SSM)
citation("SSM")
